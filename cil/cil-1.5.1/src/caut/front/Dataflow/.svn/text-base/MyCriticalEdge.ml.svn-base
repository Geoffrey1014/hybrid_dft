open Cil

module E = Errormsg

(** critical edge structure, represented as <if_stmt_id, branch_choice> *)
type criticalEdge = {

	mutable funName: string;
	mutable funId: int;
	mutable criStmtId: int; (* <funId, criStmtId> is the KEY *)
	mutable criStmtBranch: int;
	mutable criLine : int;
}

(** the global list to store the critical edges of a stmt *)
let criticalEdgeList = ref([]: criticalEdge list)

module Crieds_Set = Set.Make(
	struct 
		type t = criticalEdge
		let compare x y = 
			(* we only concern equality *)
			if x.funId = y.funId && x.criStmtId = y.criStmtId && x.criStmtBranch = y.criStmtBranch then
				0
			else 
			    -1
	end
)

let print_cried (cried: criticalEdge) =
	E.log "%s #%d %d %d #%d\n" cried.funName cried.funId cried.criStmtId cried.criStmtBranch cried.criLine
;;

(** Get the branch choice.
   Assume @pred is a if stmt and has two succs
*)
let getBranchChoice pred stmt = 
	if (List.nth pred.succs 0).sid == stmt.sid then
		0
	else
		1

(** Find the nearest "critical edge" of the @tarStmt 
	Return (stmt.sid, stmt.branch, stmt.line ) 
*)
let rec findNearestCriticalEdge (tarStmt: Cil.stmt) = 
  (* E.log "stmt id = %d, preds count = %d\n" tarStmt.sid (List.length tarStmt.preds); *)
  match tarStmt.preds with
  | [ pred ] -> (* has one pred *)
	if List.length (pred.succs) > 1 then 
		Some( pred.sid, (getBranchChoice pred tarStmt), (MyCilUtility.getStmtLoc pred) )
	else
		findNearestCriticalEdge pred
  | _ -> None (* has no pred or more than one pred *)


(** Algorithm Find Critical Edges 
   Assume the CFG info has been computed.
   1. intraprocedural
   2. start from the target statement, and tranverse its immediate/intermmediate predecessors 
      in a bfs style. And we tag each visited statements. If encounter a previous visited predecessor (in the presence of loops), we skip it.
   3. tranverse all If statements, if one of its successors is not tagged, then the other side's edge must be a critical edge.
*)

(** record all visited predecessor statements when finding critical edges for a specified statement *)
let visitedPredStmtIdList = ref ([]:int list)
(** store all critical edges for a specified statement *)
let allCriEdgesList = ref([]: criticalEdge list)


(** find @tarStmt's all critical edges in the @func *)
let findAllCriticalEdges_intrap (func: Cil.fundec) (tarStmt: Cil.stmt) = 
   (* put the target stmt id into the visited list *)
   visitedPredStmtIdList := !visitedPredStmtIdList @ [tarStmt.sid];
   (* put the target stmt into the stmt queue *)
   let stmtQueue = Queue.create () in
   Queue.add tarStmt stmtQueue;
   (
   while not (Queue.is_empty stmtQueue) do
      (* take the head stmt *)
      let sm = Queue.take stmtQueue in
      let smPredCount = List.length sm.preds in
      (* traverse its preds *)
      for i=0 to smPredCount-1 do
		let smPred = List.nth sm.preds i in
		if MyCilUtility.isIdInList smPred.sid !visitedPredStmtIdList then
		   () (* exists, skip it *)
		else begin
		   (* otherwise, keep it *)
		   Queue.add smPred stmtQueue;
		   visitedPredStmtIdList := !visitedPredStmtIdList @ [smPred.sid]
		end
      done
   done
   );
   List.iter
     begin fun stmt ->
       match stmt.skind with
       | If(_,_,_,loc) -> (* traverse all If stmts *)
			(*CAUTION : succs[0] --> true branch, succs[1] --> false branch, but after --domakeCFG, it was reversed*) 
		  let succ1 = List.nth stmt.succs 0 in (* the false branch *)
		  let succ2 = List.nth stmt.succs 1 in (* the true branch *)
		      (* If and only if there is one succ is not visited, then the other covered edge is a critical edge *)
		  if (MyCilUtility.isIdInList succ1.sid !visitedPredStmtIdList) == true && (MyCilUtility.isIdInList succ2.sid !visitedPredStmtIdList) == false then
			 begin
			let cried = {funName = func.svar.vname; funId=func.svar.vid; criStmtId = stmt.sid; criStmtBranch = 1; criLine = loc.line } in
			allCriEdgesList := !allCriEdgesList @ [cried]
			 end;
		  if (MyCilUtility.isIdInList succ1.sid !visitedPredStmtIdList) == false && (MyCilUtility.isIdInList succ2.sid !visitedPredStmtIdList) == true  then
			 begin
			let cried = {funName = func.svar.vname; funId=func.svar.vid; criStmtId = stmt.sid; criStmtBranch = 0; criLine = loc.line  } in
			allCriEdgesList := !allCriEdgesList @ [cried]
	   	     end
       | _ -> ()
     end
    func.sallstmts


(** a wrapper to find critical edges 
    Return None or Some(criticalEdge list)
*)
let getCriticalEdges (file: Cil.file) (funName: string) (stmtId: int) =
   E.log "\n\n=======[MyCriticalEdge.ml] Find Critical Edges =======\n";
   (* find the fundec *)
   let func = FindCil.fundec_by_name file funName in
   E.log "In func : %s\n" func.svar.vname;
   (
   match MyCilUtility.findStmtbyId func stmtId with (* find the target stmt *)
   | Some (sm) ->  
	 E.log "sm, id = %d, sm = %a\n" stmtId d_stmt sm;
	 ignore (findAllCriticalEdges_intrap func sm) (* find its all critical edges *)
   | None -> ()
   );
   if (List.length !allCriEdgesList) !=0 then begin
	E.log "cried count = %d\n" (List.length !allCriEdgesList);
	let ret = !allCriEdgesList in
	allCriEdgesList := []; (* clear the global list after computation *)
	visitedPredStmtIdList := [];
	Some (ret) (* If a critical edges exist for a stmt, this stmt could be reached only when this guard is satisfied *)
   end
   else begin
	allCriEdgesList := []; (* clear the global list after computation *)
	visitedPredStmtIdList := [];
	E.log "No cried\n";
	None (* If no critical edges exist for a stmt, this stmt could be reached without special guards *)
   end

(** diff crieds of two stmts in the same function.
		funName: the function where two stmts locate
		above_stmt_id: the id of the above stmt
		below_stmt_id: the id of the below stmt
	  Intuitively, the above stmt's id should be smaller than that of the below stmt
*)
let diffCriticalEdges (file: Cil.file) (funName: string) (above_stmt_id: int) (below_stmt_id: int) =
	let above_stmt_crieds = getCriticalEdges file funName above_stmt_id in
	let below_stmt_crieds = getCriticalEdges file funName below_stmt_id in
	let above_stmt_crieds_set = ref Crieds_Set.empty in (* create an empty set *)
	let below_stmt_crieds_set = ref Crieds_Set.empty in
	(match above_stmt_crieds with
	| Some (crieds) -> (* create crieds set for the above stmt *)
		above_stmt_crieds_set := List.fold_right Crieds_Set.add crieds !above_stmt_crieds_set
	| None -> ()
	);
	(match below_stmt_crieds with
	| Some (crieds) -> (* create crieds set for the below stmt *)
		below_stmt_crieds_set := List.fold_right Crieds_Set.add crieds !below_stmt_crieds_set
	| None -> ()
	);
	let diff_crieds_set = Crieds_Set.diff !below_stmt_crieds_set !above_stmt_crieds_set in
	let diff_crieds_list = Crieds_Set.elements diff_crieds_set in(* get elements as a list *) 
	List.sort (* sort the cirieds according to their stmt ids *)
		begin fun item1 item2 ->
			if item1.criStmtId = item2.criStmtId then
				0
			else if item1.criStmtId < item2.criStmtId then (* smaller --> return negative value *)
				-1
			else	(* bigger --> return positive value *)
				1
		end
	  diff_crieds_list
;;
	

	
